#define STRICT
#define NOMINMAX

#include <opencv2/core/utility.hpp>
#include <opencv2/video/tracking.hpp>
#include <opencv2/videoio.hpp> // videoioのヘッダーをインクルード
#include <opencv2/highgui.hpp> // highguiのヘッダーをインクルード
#include <opencv2/imgproc.hpp>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/imgproc/imgproc_c.h>
#include <opencv2/highgui/highgui_c.h>
#include <opencv2/objdetect/detection_based_tracker.hpp>
#include <iostream>
#include<string>
#include <vector>
#include <stdio.h>
#include<math.h>
#include<process.h>
#include<windows.h>
#include<windowsx.h>
#include <tchar.h>
#include <opencv2/opencv.hpp>
#include <opencv2/core.hpp>
#include <opencv2/video.hpp>
#include<cstring>
#include <opencv2/imgcodecs.hpp>
#include <opencv2/tracking.hpp>
#include <numeric>      // std::iota
#include <algorithm>    // std::sort, std::stable_sort
#include <opencv2/video/background_segm.hpp>
#include <functional>
#include<stdlib.h>　//WM＿TIMERの精度が心配な時
#include<time.h>　　//WM＿TIMERの精度が心配な時
#include <random>
#include<map>

#ifdef _DEBUG
#pragma comment(lib, "opencv_world452d.lib")
#else
#pragma comment(lib, "opencv_world452.lib")
#endif

using namespace cv;
using namespace std;

double PI = (double)354 / (double)113;
int xb = 0, yb = 0;
int st = 0, ct = 0;

Mat img;
Mat diff;
Point square;

SYSTEMTIME systime;//時間記録用
FILE* fp = NULL;
char FileName[127] = { "FILE_AD" };//ファイルの名前用の文字列



Mat Bit_Wise2(Mat img1, Mat img2) {
	Mat img1_gry, img2_gry, img_gry;
	cvtColor(img1, img1_gry, COLOR_BGR2GRAY);
	cvtColor(img2, img2_gry, COLOR_BGR2GRAY);
	absdiff(img1_gry, img2_gry, img_gry);

	return img_gry;
}

Point center(Point max, Point min, Point MAX, Point MIN) {
	Point v;
	int k = 0;
	double s1 = 0, s2 = 0;
	int P1X = MIN.x;
	int P1Y = MIN.y;
	int P2Y = min.y;
	int P2X = min.x;
	int P3X = MAX.x;
	int P3Y = MAX.y;
	int P4Y = max.y;
	int P4X = max.x;

	s1 = ((P4X - P2X) * (P1Y - P2Y) - (P4Y - P2Y) * (P1X - P2X)) / 2;
	s2 = ((P4X - P2X) * (P2Y - P3Y) - (P4Y - P2Y) * (P2X - P3X)) / 2;

	v = Point(0, 0);
	v.x = P1X + ((double)P3X - (double)P1X) * s1 / (s1 + s2);
	v.y = P1Y + ((double)P3Y - (double)P1Y) * s1 / (s1 + s2);

	return v;
}

Mat templateMatch(Mat src, Mat tmp, Mat frame) {

	int sumx = 0, sumy = 0;
	const int __TARGET_NUM__ = 30;
	Mat output, dst;
	dst = frame.clone();
	//テンプレートマッチング
	matchTemplate(src, tmp, output, TM_CCOEFF);
	//0~1の値に標準化
	normalize(output, output, 0, 1, NORM_MINMAX, -1, Mat());
	//2次元から1次元へ変換
	Mat one_row = output.reshape(1, 1);

	vector<float> one_row_vec;
	vector<float> one_row_index;

	//cv::Mat -> std::vector に変換
	one_row_vec.assign(one_row.begin<float>(), one_row.end<float>());
	vector<int> index(one_row_vec.size());

	//ソートインデックス配列用に整数列を作成する(0,1,2,3,4,5......)
	iota(index.begin(), index.end(), 0);

	//ソートをかける
	sort(index.begin(), index.end(), [&](int a, int b) {return one_row_vec[a] > one_row_vec[b]; });

	for (int i = 0; i < __TARGET_NUM__; i++) {
		//std::cout << index[i] << ":" << one_row_vec[index[i]] << std::endl;
		if (one_row_vec[index[i]] > 0.999) {
			// 1次元から2次元に変換 
			int x = index[i] % output.cols;
			int y = index[i] / output.cols;

			Rect roi_rect = Rect(x, y, tmp.cols, tmp.rows);
			rectangle(dst, roi_rect, Scalar(0, 255, 255), 3);
			xb = x;
			yb = y;
		}
	}
	return dst;
}

pair<Point, double> three_seg(vector<KeyPoint> keypoint) {
	Point v = Point(0, 0);
	double theta = 0;
	vector<int> m1(5);
	vector<int> m2(5);
	vector<int> m3(5);
	int a = 0;
	double sumx = 0, sumy = 0;
	Point G = Point(0, 0);
	for (int i = 0; i < keypoint.size(); i++) {
		circle(img, keypoint.at(i).pt, 1, Scalar(0, 255, 255), 2, 5);
		sumx += (double)keypoint.at(i).pt.x;
		sumy += (double)keypoint.at(i).pt.y;
		a++;
	}
	G.x = sumx / (double)a;
	G.y = sumy / (double)a;
	//circle(img, G, 1, Scalar(55, 55, 155), 3, 5);
	vector<pair<double, double>> data(a);//radian,distance
	for (int j = 0; j < a; j++) {
		data.at(j).second = sqrt(pow(G.x - (double)keypoint.at(j).pt.x, 2) + pow(G.y - (double)keypoint.at(j).pt.y, 2));
		data.at(j).first = atan2(G.y - (double)keypoint.at(j).pt.y, G.x - (double)keypoint.at(j).pt.x);
		//printf("%f,%f\n", data.at(j).first, data.at(j).second);
	}
	
	sort(data.begin(), data.end());
	//vector<pair<double, double>> store(6);//distance,radian
	vector<pair<double, double>> store(12);//distance,radian
	vector<double> dstore(12);//distance,radian
	Point edge1 = Point(0, 0);
	Point edge2 = Point(0, 0);
	Point edge3 = Point(0, 0);
	Point edge_tmp = Point(0, 0);
	//double set_radian = -(double)3894 / (double)1356;//2.75
	//double set_radian = -(double)1770 / (double)678;//2.5
	//double base_radian = -(double)354 / (double)113;
	double set_radian = -PI * (double)5 / (double)6;//2.5
	double base_radian = -PI;
	int s = 0;
	
	//ラジアン6等分&最大値取得
	for (int k = 0; k < a; k++) {
		//printf("%f,%f\n", data.at(k).first, data.at(k).second);
		if (data.at(k).first > set_radian) {
			//set_radian += (double)354 / (double)1356;//0.25
			//base_radian += (double)354 / (double)1356;
			//set_radian += (double)354 / (double)678;//0.5
			//base_radian += (double)354 / (double)678;
			set_radian += PI/ (double)6;//0.5
			base_radian += PI / (double)6;
			//fprintf(fp, "%d,%f\n", s, dstore.at(s));
			s++;
			if (s > 11) {
				break;
			}
		}

		if (data.at(k).first < set_radian && data.at(k).first > base_radian) {
			dstore.at(s) += data.at(k).second;
			if (store.at(s).first < data.at(k).second) {
				store.at(s).first = data.at(k).second;
				store.at(s).second = data.at(k).first;
				//circle(img, keypoint.at(k).pt, 1, Scalar(0, 255, 255), 2, 5);
			}
		}
	}

	//fprintf(fp, "\n");
	printf("\n");
	
	vector<int> xx(4);
	int marcury = 1;
	xx.at(0) = 0;
	for (int w = 1; w < 11; w++) {
		if (dstore.at(w - 1) < dstore.at(w)) {
			if (dstore.at(w) > dstore.at(w + 1) && dstore.at(w) > 500) {
				xx.at(marcury) = w;
				//printf("%d,%d\n", w, marqry);
				marcury += 1;
			}
		}
		if (marcury == 4) {
			xx.at(0) = xx.at(1);
			xx.at(1) = xx.at(2);
			xx.at(2) = xx.at(3);
			break;
		}
	}
	if (marcury <3) {
		exit;
	}
	
	//sort(store.rbegin(), store.rend());
	/*
	for (int b = 0; b < 8; b++) {
		for (int bb = 11; bb > 0; bb--) {
			if (abs(abs(store.at(b + 1).second) - abs(store.at(b).second)) < PI / 6) {
				store.at(b + 1) = store.at(b + 2);
				store.at(b + 2) = store.at(b + 3);
				
			}
			else {
				break;
			}
		}
	}
	*/
	vector<double> distance(a);
	int xx_tmp = 0;
	for (int q = 0; q < a; q++) {
		Scalar color(rand() & 255, rand() & 255, rand() & 255);
		distance.at(q) = sqrt(pow(G.x - (double)keypoint.at(q).pt.x, 2) + pow(G.y - (double)keypoint.at(q).pt.y, 2));
		if (distance.at(q) == store.at(xx.at(0)).first) {
			edge1 = keypoint.at(q).pt;
		}
		else if (distance.at(q) == store.at(xx.at(1)).first) {
			edge2 = keypoint.at(q).pt;
		}
		else if (distance.at(q) == store.at(xx.at(2)).first) {
			edge3 = keypoint.at(q).pt;
		}
	}
	
	if (edge1.x > edge2.x) {
		edge_tmp = edge2;
		edge2 = edge1;
		edge1 = edge_tmp;
		xx_tmp = xx.at(1);
		xx.at(1) = xx.at(0);
		xx.at(0) = xx_tmp;
	}
	if (edge1.x > edge3.x) {
		edge_tmp = edge3;
		edge3 = edge1;
		edge1 = edge_tmp;
		xx_tmp = xx.at(2);
		xx.at(2) = xx.at(0);
		xx.at(0) = xx_tmp;
	}
	/*
	vector< vector<Point> > contours;
	vector< vector<Point> > contours_subset;
	vector<Vec4i> hierarchy;
	Mat gry;
	cvtColor(img, gry, COLOR_BGR2GRAY);
	findContours(gry, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
	int idx = 0;
	int size = 0;
	int Index = 0;
	for (; idx >= 0; idx = hierarchy[idx][0])
	{
		if (contourArea(contours.at(idx)) > size) {
			size = contourArea(contours.at(idx));
			Index = idx;
		}
	}
	if (contourArea(contours.at(Index)) < 20000) {
		v = Point(0, 0);
		return { v,theta };
	}
	*/
	if (sqrt(pow(edge2.x - edge3.x, 2) + pow(edge2.y - edge3.y, 2)) < 40) {
		Scalar color(rand() & 255, rand() & 255, rand() & 255);
		circle(img, edge1, 3, Scalar(0, 0, 255), 2, 5);
		circle(img, edge2, 3, Scalar(0, 255, 0), 2, 5);
		circle(img, edge3, 3, Scalar(255, 0, 0), 2, 5);
		//imshow("error", img);
		//waitKey(0);
	}

	vector<double>distance1(a);
	vector<double>distance2(a);
	vector<double>distance3(a);
	vector<vector<Point>>keep1(2, vector<Point>(a));//5
	vector<vector<Point>>keep2(2, vector<Point>(a));
	vector<vector<Point>>keep3(2, vector<Point>(a));
	vector<Point> G1(2);//5
	vector<Point> G2(2);
	vector<Point> G3(2);
	vector<pair<double, double>>G1maxstore(12);//6
	vector<pair<double, double>>G1minstore(12);
	vector<pair<double, double>>G2maxstore(12);
	vector<pair<double, double>>G2minstore(12);
	vector<pair<double, double>>G3maxstore(12);
	vector<pair<double, double>>G3minstore(12);
	vector<double> asp1(2);//5
	vector<double> asp2(2);
	vector<double> asp3(2);

	for (int r = 0; r < 2; r++) {//領域増加
		int u1 = 0, u2 = 0, u3 = 0;
		double sumx1 = 0, sumx2 = 0, sumx3 = 0;
		double sumy1 = 0, sumy2 = 0, sumy3 = 0;
		
		//double set_distance = (store.at(0).first / 3)+(store.at(0).first / 8)*r;
		double set_distance1 = (store.at(xx.at(0)).first / 8) * (r + 6);
		double set_distance2 = (store.at(xx.at(1)).first / 8) * (r + 6);
		double set_distance3 = (store.at(xx.at(2)).first / 8) * (r + 6);
		
		for (int u = 0; u < a; u++) {//全体検索
			distance1.at(u) = sqrt(pow(edge1.x - (double)keypoint.at(u).pt.x, 2) + pow(edge1.y - (double)keypoint.at(u).pt.y, 2));
			distance2.at(u) = sqrt(pow(edge2.x - (double)keypoint.at(u).pt.x, 2) + pow(edge2.y - (double)keypoint.at(u).pt.y, 2));
			distance3.at(u) = sqrt(pow(edge3.x - (double)keypoint.at(u).pt.x, 2) + pow(edge3.y - (double)keypoint.at(u).pt.y, 2));
			if (distance1.at(u) < set_distance1) {
				sumx1 += keypoint.at(u).pt.x;
				sumy1 += keypoint.at(u).pt.y;
				keep1.at(r).at(u1) = keypoint.at(u).pt;
				//circle(img, keypoint.at(u).pt, 1, Scalar(0, 0, 255), 2, 5);
				u1++;
			}

			if (distance2.at(u) < set_distance2) {
				sumx2 += keypoint.at(u).pt.x;
				sumy2 += keypoint.at(u).pt.y;
				keep2.at(r).at(u2) = keypoint.at(u).pt;
				//circle(img, keypoint.at(u).pt, 1, Scalar(0, 255, 0), 2, 5);
				u2++;
			}

			if (distance3.at(u) < set_distance3) {
				sumx3 += keypoint.at(u).pt.x;
				sumy3 += keypoint.at(u).pt.y;
				keep3.at(r).at(u3) = keypoint.at(u).pt;
				//circle(img, keypoint.at(u).pt, 1, Scalar(255, 0, 0), 2, 5);
				u3++;
			}
		}
		m1.at(r) = u1;
		m2.at(r) = u2;
		m3.at(r) = u3;
		G1.at(r).x = sumx1 / (double)u1;
		G1.at(r).y = sumy1 / (double)u1;
		G2.at(r).x = sumx2 / (double)u2;
		G2.at(r).y = sumy2 / (double)u2;
		G3.at(r).x = sumx3 / (double)u3;
		G3.at(r).y = sumy3 / (double)u3;

		vector<pair<double, double>> G1data(u1);//radian,distance
		vector<pair<double, double>> G2data(u2);//radian,distance
		vector<pair<double, double>> G3data(u3);//radian,distance

		//長さと角度の計算
		for (int r1 = 0; r1 < u1; r1++) {
			G1data.at(r1).second = sqrt(pow(G1.at(r).x - keep1.at(r).at(r1).x, 2) + pow(G1.at(r).y - keep1.at(r).at(r1).y, 2));
			G1data.at(r1).first = atan2(G1.at(r).y - keep1.at(r).at(r1).y, G1.at(r).x - keep1.at(r).at(r1).x);
		}
		for (int r2 = 0; r2 < u2; r2++) {
			G2data.at(r2).second = sqrt(pow(G2.at(r).x - keep2.at(r).at(r2).x, 2) + pow(G2.at(r).y - keep2.at(r).at(r2).y, 2));
			G2data.at(r2).first = atan2(G2.at(r).y - keep2.at(r).at(r2).y, G2.at(r).x - keep2.at(r).at(r2).x);
		}
		for (int r3 = 0; r3 < u3; r3++) {
			G3data.at(r3).second = sqrt(pow(G3.at(r).x - keep3.at(r).at(r3).x, 2) + pow(G3.at(r).y - keep3.at(r).at(r3).y, 2));
			G3data.at(r3).first = atan2(G3.at(r).y - keep3.at(r).at(r3).y, G3.at(r).x - keep3.at(r).at(r3).x);
		}

		sort(G1data.begin(), G1data.end());
		sort(G2data.begin(), G2data.end());
		sort(G3data.begin(), G3data.end());
		int s1 = 0, s2 = 0, s3 = 0;
		//double set_radian1 = -2;
		//double set_radian2 = -2;
		//double set_radian3 = -2;
		double set_radian1 = -PI * (double)5 / (double)6;
		double set_radian2 = -PI * (double)5 / (double)6;
		double set_radian3 = -PI * (double)5 / (double)6;
		double alpha1 = 0, beta1 = 0, gamma1 = 0, delta1 = 0, epsilon1 = 0;
		double alpha2 = 0, beta2 = 0, gamma2 = 0, delta2 = 0, epsilon2 = 0;
		double alpha3 = 0, beta3 = 0, gamma3 = 0, delta3 = 0, epsilon3 = 0;
		//ラジアン6等分&最大値取得
		for (int e1 = 0; e1 < u1; e1++) {

			if (e1 == 0) {
				G1minstore.at(s1).first = G1data.at(e1).second;
				G1minstore.at(s1).second = G1data.at(e1).first;
			}

			if (G1data.at(e1).first > set_radian1) {
				set_radian1 += 1;
				s1++;
				if (s1 > 5) {
					break;
				}
				G1minstore.at(s1).first = G1data.at(e1).second;
				G1minstore.at(s1).second = G1data.at(e1).first;
			}

			if (G1data.at(e1).first < set_radian1) {
				if (G1maxstore.at(s1).first < G1data.at(e1).second) {
					G1maxstore.at(s1).first = G1data.at(e1).second;
					G1maxstore.at(s1).second = G1data.at(e1).first;
				}

				if (G1minstore.at(s1).first > G1data.at(e1).second) {
					G1minstore.at(s1).first = G1data.at(e1).second;
					G1minstore.at(s1).second = G1data.at(e1).first;
				}
			}
		}
		for (int e2 = 0; e2 < u2; e2++) {
			if (e2 == 0) {
				G2minstore.at(s2).first = G2data.at(e2).second;
				G2minstore.at(s2).second = G2data.at(e2).first;
			}

			if (G2data.at(e2).first > set_radian2) {
				set_radian2 += 1;
				s2++;
				if (s2 > 5) {
					break;
				}
				G2minstore.at(s2).first = G2data.at(e2).second;
				G2minstore.at(s2).second = G2data.at(e2).first;
			}

			if (G2data.at(e2).first < set_radian2) {
				if (G2maxstore.at(s2).first < G2data.at(e2).second) {
					G2maxstore.at(s2).first = G2data.at(e2).second;
					G2maxstore.at(s2).second = G2data.at(e2).first;
				}

				if (G2minstore.at(s2).first > G2data.at(e2).second) {
					G2minstore.at(s2).first = G2data.at(e2).second;
					G2minstore.at(s2).second = G2data.at(e2).first;
				}
			}
		}
		for (int e3 = 0; e3 < u3; e3++) {
			if (e3 == 0) {
				G3minstore.at(s3).first = G3data.at(e3).second;
				G3minstore.at(s3).second = G3data.at(e3).first;
			}

			if (G3data.at(e3).first > set_radian3) {
				set_radian3 += 1;
				s3++;
				if (s3 > 5) {
					break;
				}
				G3minstore.at(s3).first = G3data.at(e3).second;
				G3minstore.at(s3).second = G3data.at(e3).first;
			}

			if (G3data.at(e3).first < set_radian3) {
				if (G3maxstore.at(s3).first < G3data.at(e3).second) {
					G3maxstore.at(s3).first = G3data.at(e3).second;
					G3maxstore.at(s3).second = G3data.at(e3).first;
				}

				if (G3minstore.at(s3).first > G3data.at(e3).second) {
					G3minstore.at(s3).first = G3data.at(e3).second;
					G3minstore.at(s3).second = G3data.at(e3).first;
				}
			}
		}

		sort(G1maxstore.rbegin(), G1maxstore.rend());
		sort(G2maxstore.rbegin(), G2maxstore.rend());
		sort(G3maxstore.rbegin(), G3maxstore.rend());
		sort(G1minstore.begin(), G1minstore.end());
		sort(G2minstore.begin(), G2minstore.end());
		sort(G3minstore.begin(), G3minstore.end());

		double ituki = 0, kyou = 0, siba = 0, karin = 0, wataru = 0;
		double kagetu = 0, fuyou = 0, purim = 0, genzi = 0, mikuri = 0;
		double ryou = 0, kikuno = 0, oba = 0, goyou = 0, sirona = 0;
		int neithio = 0, crobat = 0, kairiky = 0, hellgar = 0, kairyu = 0;
		int abusol = 0, yamirami = 0, todozeruga = 0, bohmander = 0, milokaross = 0;
		int dorapion = 0, kabaldon = 0, goukazaru = 0, erureido = 0, gaburias = 0;
		
		alpha1 = G1maxstore.at(0).second;
		if (alpha1 > 0) {
			beta1 = alpha1 - PI;
			gamma1 = alpha1 - PI / (double)2;
			if (alpha1 < PI / (double)2) {
				delta1 = alpha1 + PI / (double)2;
				if (delta1 > PI * (double)9 / (double)10) {
					epsilon1 = delta1 - PI * (double)19 / (double)10;
				}
			}
			else {
				delta1 = alpha1 - PI * (double)3 / (double)2;
				if (delta1 < -PI * (double)9 / (double)10) {
					epsilon1 = delta1 + PI * (double)19 / (double)10;
				}
			}
		}
		else {
			beta1 = alpha1 + PI;
			gamma1 = alpha1 + PI / (double)2;
			if (alpha1 > -PI / (double)2) {
				delta1 = alpha1 - PI / (double)2;
				if (delta1 < -PI * (double)9 / (double)10) {
					epsilon1 = delta1 + PI * (double)19 / (double)10;
				}
			}
			else {
				delta1 = alpha1 + PI * (double)3 / (double)2;
				if (delta1 > PI * (double)9 / (double)10) {
					epsilon1 = delta1 - PI * (double)19 / (double)10;
				}
			}
		}
		for (int sanda = 0; sanda < u1; sanda++) {
			if (G1data.at(sanda).first > alpha1 - PI / (double)10 && G1data.at(sanda).first < alpha1 + PI / (double)10 && neithio<5) {
				ituki += G1data.at(sanda).second;
				neithio++;
			}
			else if (G1data.at(sanda).first > beta1 - PI / (double)10 && G1data.at(sanda).first < beta1 + PI / (double)10 && crobat<5) {
				kyou+= G1data.at(sanda).second;
				crobat++;
			}
			else if (G1data.at(sanda).first > gamma1 - PI / (double)10 && G1data.at(sanda).first < gamma1 + PI / (double)10 && kairiky<5) {
				siba += G1data.at(sanda).second;
				kairiky++;
			}
			else if (G1data.at(sanda).first > delta1 - PI / (double)10 && G1data.at(sanda).first < delta1 + PI / (double)10 && hellgar<5) {
				karin+= G1data.at(sanda).second;
				hellgar++;
			}

			if (epsilon1 > 0) {
				if (G1data.at(sanda).first > epsilon1 && kairyu<5) {
					wataru += G1data.at(sanda).second;
					kairyu++;
				}
			}
			else if (epsilon1 < 0) {
				if (G1data.at(sanda).first < epsilon1 && kairyu<5) {
					wataru += G1data.at(sanda).second;
					kairyu++;
				}
			}
		}
		if (kairyu > 0) {
			wataru = wataru / (double)kairyu;
		}
		karin += wataru;

		alpha2 = G2maxstore.at(0).second;
		if (alpha2 > 0) {
			beta2 = alpha2 - PI;
			gamma2 = alpha2 - PI / (double)2;
			if (alpha2 < PI / (double)2) {
				delta2 = alpha2 + PI / (double)2;
				if (delta2 > PI * (double)9 / (double)10) {
					epsilon2 = delta2 - PI * (double)19 / (double)10;
				}
			}
			else {
				delta2 = alpha2 - PI * (double)3 / (double)2;
				if (delta2 < -PI * (double)9 / (double)10) {
					epsilon2 = delta2 + PI * (double)19 / (double)10;
				}
			}
		}
		else {
			beta2 = alpha2 + PI;
			gamma2 = alpha2 + PI / (double)2;
			if (alpha2 > -PI / (double)2) {
				delta2 = alpha2 - PI / (double)2;
				if (delta2 < -PI * (double)9 / (double)10) {
					epsilon2 = delta2 + PI * (double)19 / (double)10;
				}
			}
			else {
				delta2 = alpha2 + PI * (double)3 / (double)2;
				if (delta2 > PI * (double)9 / (double)10) {
					epsilon2 = delta2 - PI * (double)19 / (double)10;
				}
			}
		}
		for (int fire = 0; fire < u2; fire++) {
			if (G2data.at(fire).first > alpha2 - PI / (double)10 && G2data.at(fire).first < alpha2 + PI / (double)10 && abusol<5) {
				kagetu += G2data.at(fire).second;
				abusol++;
			}
			else if (G2data.at(fire).first > beta2 - PI / (double)10 && G2data.at(fire).first < beta2 + PI / (double)10 && yamirami<5) {
				fuyou += G2data.at(fire).second;
				yamirami++;
			}
			else if (G2data.at(fire).first > gamma2 - PI / (double)10 && G2data.at(fire).first < gamma2 + PI / (double)10 && todozeruga<5) {
				purim += G2data.at(fire).second;
				todozeruga++;
			}
			else if (G2data.at(fire).first > delta2 - PI / (double)10 && G2data.at(fire).first < delta2 + PI / (double)10 && bohmander<5) {
				genzi += G2data.at(fire).second;
				bohmander++;
			}

			if (epsilon2 > 0) {
				if (G2data.at(fire).first > epsilon2 && milokaross<5){
					mikuri += G2data.at(fire).second;
					milokaross++;
				}
			}
			else if (epsilon2 < 0) {
				if (G2data.at(fire).first < epsilon2 && milokaross<5) {
					mikuri += G2data.at(fire).second;
					milokaross++;
				}
			}
		}
		if (milokaross > 0) {
			mikuri = mikuri / (double)milokaross;
		}
		genzi += mikuri;

		alpha3 = G3maxstore.at(0).second;
		if (alpha3 > 0) {
			beta3 = alpha3 - PI;
			gamma3 = alpha3 - PI / (double)2;
			if (alpha3 < PI / (double)2) {
				delta3 = alpha3 + PI / (double)2;
				if (delta3 > PI * (double)9 / (double)10) {
					epsilon3 = delta3 - PI * (double)19 / (double)10;
				}
			}
			else {
				delta3 = alpha3 - PI * (double)3 / (double)2;
				if (delta3 < -PI * (double)9 / (double)10) {
					epsilon3 = delta3 + PI * (double)19 / (double)10;
				}
			}
		}
		else {
			beta3 = alpha3 + PI;
			gamma3 = alpha3 + PI / (double)2;
			if (alpha3 > -PI / (double)2) {
				delta3 = alpha3 - PI / (double)2;
				if (delta3 < -PI * (double)9 / (double)10) {
					epsilon3 = delta3 + PI * (double)19 / (double)10;
				}
			}
			else {
				delta3 = alpha3 + PI * (double)3 / (double)2;
				if (delta3 > PI * (double)9 / (double)10) {
					epsilon3 = delta3 - PI * (double)19 / (double)10;
				}
			}
		}
		for (int freezer = 0; freezer < u3; freezer++) {
			if (G3data.at(freezer).first > alpha3 - PI / (double)10 && G3data.at(freezer).first < alpha3 + PI / (double)10 && dorapion<5) {
				ryou += G3data.at(freezer).second;
				dorapion++;
			}
			else if (G3data.at(freezer).first > beta3 - PI / (double)10 && G3data.at(freezer).first < beta3 + PI / (double)10 && kabaldon<5) {
				kikuno += G3data.at(freezer).second;
				kabaldon++;
			}
			else if (G3data.at(freezer).first > gamma3 - PI / (double)10 && G3data.at(freezer).first < gamma3 + PI / (double)10 && goukazaru<5) {
				oba += G3data.at(freezer).second;
				goukazaru++;
			}
			else if (G3data.at(freezer).first > delta3 - PI / (double)10 && G3data.at(freezer).first < delta3 + PI / (double)10 && erureido<5) {
				goyou += G3data.at(freezer).second;
				erureido++;
			}

			if (epsilon3 > 0) {
				if (G3data.at(freezer).first > epsilon3 && gaburias<5) {
					sirona += G3data.at(freezer).second;
					gaburias++;
				}
			}
			else if (epsilon3 < 0) {
				if (G3data.at(freezer).first < epsilon3 && gaburias<5) {
					sirona += G3data.at(freezer).second;
					gaburias++;
				}
			}
		}
		if (gaburias > 0) {
			sirona = sirona / (double)gaburias;
		}
		goyou += sirona;

		if (s1 == 0 || s2 == 0 || s3 == 0) {
			asp1.at(r) = 0;
			asp2.at(r) = 0;
			asp3.at(r) = 0;
			continue;
		}

		//asp1.at(r) = G1maxstore.at(0).first / G1minstore.at((double)6 - s1).first;
		//asp2.at(r) = G2maxstore.at(0).first / G2minstore.at((double)6 - s2).first;
		//asp3.at(r) = G3maxstore.at(0).first / G3minstore.at((double)6 - s3).first;
		asp1.at(r) = (ituki + kyou)/ (siba + karin);
		asp2.at(r) = (kagetu + fuyou)/ (purim + genzi);
		asp3.at(r) = (ryou + kikuno)/ (oba + goyou);

		if ((siba + karin) == 0) {
			asp1.at(r) = 0;
		}
		if ((purim + genzi) == 0) {
			asp2.at(r) = 0;
		}
		if ((oba + goyou) == 0) {
			asp3.at(r) = 0;
		}
		//printf("red:%f green:%f blue:%f\n", asp1.at(r), asp2.at(r), asp3.at(r));
		//printf("%f ,%f ,%f ,%f ,%f \n", ryou,kikuno,oba,goyou,asp3.at(r));
		if (r == 4) {
			//imshow("ar", img);
			waitKey(1);
		}
	}

	double base_asp1 = 0;
	double base_asp2 = 0;
	double base_asp3 = 0;
	int index1 = 0;
	int index2 = 0;
	int index3 = 0;

	for (int z = 0; z < 2; z++) {
		if (asp1.at(z) > base_asp1) {
			base_asp1 = asp1.at(z);
			index1 = z;
		}
		if (asp2.at(z) > base_asp2) {
			base_asp2 = asp2.at(z);
			index2 = z;
		}
		if (asp3.at(z) > base_asp3) {
			base_asp3 = asp3.at(z);
			index3 = z;
		}
	}
	printf("%d,%d,%d\n", index1, index2, index3);
	vector<double> dev1x(m1.at(index1));
	vector<double> dev1y(m1.at(index1));
	vector<double> dev2x(m2.at(index2));
	vector<double> dev2y(m2.at(index2));
	vector<double> dev3x(m3.at(index3));
	vector<double> dev3y(m3.at(index3));
	double powdev1x = 0, powdev2x = 0, powdev3x = 0;
	double powdev1y = 0, powdev2y = 0, powdev3y = 0;
	double var1x = 0, var2x = 0, var3x = 0;
	double var1y = 0, var2y = 0, var3y = 0;
	double Sdev1 = 0, Sdev2 = 0, Sdev3 = 0;
	double cov1 = 0, cov2 = 0, cov3 = 0;
	double a1 = 0, a2 = 0, a3 = 0;
	double b1 = 0, b2 = 0, b3 = 0;
	double c1x = 0, c2x = 0, c3x = 0;
	double c1y = 0, c2y = 0, c3y = 0;
	
	for (int n1 = 0; n1 < m1.at(index1); n1++) {
		//printf("%d,%d\n", keep1.at(index1).at(n1).x, keep1.at(index1).at(n1).y);
		circle(img, keep1.at(index1).at(n1), 5, Scalar(0, 0, 255), -1, 5);
		dev1x.at(n1) = keep1.at(index1).at(n1).x - G1.at(index1).x;
		dev1y.at(n1) = keep1.at(index1).at(n1).y - G1.at(index1).y;
		powdev1x += pow(dev1x.at(n1), 2);
		powdev1y += pow(dev1y.at(n1), 2);
		Sdev1 += dev1x.at(n1) * dev1y.at(n1);
	}
	var1x = powdev1x / (double)m1.at(index1);
	var1y = powdev1y / (double)m1.at(index1);
	cov1 = Sdev1 / (double)m1.at(index1);

	for (int n2 = 0; n2 < m2.at(index2); n2++) {
		circle(img, keep2.at(index2).at(n2), 5, Scalar(0, 255, 0), -1, 5);
		dev2x.at(n2) = keep2.at(index2).at(n2).x - G2.at(index2).x;
		dev2y.at(n2) = keep2.at(index2).at(n2).y - G2.at(index2).y;
		powdev2x += pow(dev2x.at(n2), 2);
		powdev2y += pow(dev2y.at(n2), 2);
		Sdev2 += dev2x.at(n2) * dev2y.at(n2);
	}
	var2x = powdev2x / (double)m2.at(index2);
	var2y = powdev2y / (double)m2.at(index2);
	cov2 = Sdev2 / (double)m2.at(index2);

	for (int n3 = 0; n3 < m3.at(index3); n3++) {
		circle(img, keep3.at(index3).at(n3), 5, Scalar(255, 0, 0), -1, 5);
		dev3x.at(n3) = keep3.at(index3).at(n3).x - G3.at(index3).x;
		dev3y.at(n3) = keep3.at(index3).at(n3).y - G3.at(index3).y;
		powdev3x += pow(dev3x.at(n3), 2);
		powdev3y += pow(dev3y.at(n3), 2);
		Sdev3 += dev3x.at(n3) * dev3y.at(n3);
	}
	var3x = powdev3x / (double)m3.at(index3);
	var3y = powdev3y / (double)m3.at(index3);
	cov3 = Sdev3 / (double)m3.at(index3);

	a1 = cov1 / var1x;
	a2 = cov2 / var2x;
	a3 = cov3 / var3x;
	b1 = G1.at(index1).y - a1 * G1.at(index1).x;
	b2 = G2.at(index2).y - a2 * G2.at(index2).x;
	b3 = G3.at(index3).y - a3 * G3.at(index3).x;
	c1x = (b2 - b1) / (a1 - a2);
	c1y = a1 * c1x + b1;
	c2x = (b3 - b2) / (a2 - a3);
	c2y = a2 * c2x + b2;
	c3x = (b1 - b3) / (a3 - a1);
	c3y = a3 * c3x + b3;
	
	//circle(img, Point(c1x, c1y), 5, Scalar(0, 255, 255), -1, 5);
	//circle(img, Point(c2x, c2y), 5, Scalar(255, 255, 0), -1, 5);
	//circle(img, Point(c3x, c3y), 5, Scalar(255, 0, 255), -1, 5);
	//line(img, Point(c1x,c1y), G1.at(index1), Scalar(0, 0, 200), 3, 4);
	//line(img, Point(c2x, c2y), G2.at(index2), Scalar(0, 200, 0), 3, 4);
	//line(img, Point(c3x, c3y), G3.at(index3), Scalar(200, 0, 0), 3, 4);
	line(img, edge2, G2.at(index2), Scalar(0, 200, 255), 3, 4);
	line(img, edge3, G3.at(index3), Scalar(200, 0, 255), 3, 4);
	Point v1 = center(edge1, G1.at(index1), edge2, G2.at(index2));
	Point v2 = center(edge2, G2.at(index2), edge3, G3.at(index3));
	Point v3 = center(edge3, G3.at(index3), edge1, G1.at(index1));
	v.x = (v1.x + v2.x + v3.x) / 3;
	v.y = (v1.y + v2.y + v3.y) / 3;
	
	//v.x = (c1x + c2x + c3x) / 3;
	//v.y = (c1y + c2y + c3y) / 3;
	/*
	Point v1 = center(edge2, G2.at(index2), edge1, G1.at(index1));
	Point v2 = center(edge3, G3.at(index3), edge2, G2.at(index2));
	Point v3 = center(edge1, G1.at(index1), edge3, G3.at(index3));
	v.x = (v1.x + v2.x + v3.x) / 3;
	v.y = (v1.y + v2.y + v3.y) / 3;
	*/

	Point A = Point(0, 0);
	Point B = Point(0, 0);
	double cos = 0;
	//if (v.x > 0 && v.y > 0) {
	if (edge1.x > 0 && edge1.y > 0) {
		square = Point(90,80);
		A.x = edge2.x - square.x;
		A.y = edge2.y - square.y;
		B.x = edge3.x - square.x;
		B.y = edge3.y - square.y;
		cos = ((double)A.x * (double)B.x + (double)A.y * (double)B.y) / (sqrt(pow(A.x, 2) + pow(A.y, 2)) * sqrt(pow(B.x, 2) + pow(B.y, 2)));
		theta = acos(cos) * (double)180 / PI;
	}
	if (v != Point(0, 0)) {
		circle(img, v, 10, Scalar(255, 0, 255), 3, 8);
	}
	imshow("open", img);
	return { v,theta };
}

int main(int argc, const char* argv[]) {
	VideoCapture capture(0);

	Mat frame1, frame2, gry;
	Mat img2, img3, img99;
	Rect selection(0, 50, 700, 350);
	Mat edge;
	Point G = Point(0, 0);
	int d = 0;

	GetLocalTime(&systime);
	sprintf_s(FileName, "%d%d_%dh%dm%d.csv", systime.wMonth, systime.wDay, systime.wHour, systime.wMinute, systime.wSecond);
	errno_t error;
	error = fopen_s(&fp, FileName, "w+");//ファイル書き込み呼び出し
	Rect roiroi = Rect(255, 155, 190, 170);
	Mat ex;
	for (;;) {
		capture >> frame1;
		ex = frame1.clone();
		rectangle(ex, roiroi, Scalar(255, 0, 255), 3, 8);
		imshow("test", ex);
		if (waitKey(33) == 27) {
			break;
		}
	}
	Mat frame3, gry1, gry2, tmpimg, tmpedge;
	Mat origin1, origin2, origingry1, origingry2, origintmp, originedge;
	Mat src, dst, difftmp, edgetmp, edgetmp_roi;
	Mat normal;
	Mat matching, matching2;
	Mat view;
	Point v = Point(0, 0);
	Rect roi, keep_roi;
	double len = 0;
	double theta = 0;
	Rect selection2(40, 60, 610, 300);
	int venus = 0;
	int saturn = 0;

	capture >> src;
	src = src(roiroi);
	dst = frame1(roiroi).clone();
	difftmp = Bit_Wise2(src, dst);
	difftmp = difftmp;
	medianBlur(difftmp, difftmp, 3);
	Canny(difftmp, edgetmp_roi, 50, 100, 3, true);
	//dilate(edgetmp_roi, edgetmp_roi, Mat(), Point(-1, -1), 3);
	destroyAllWindows();
	xb = 205;
	yb = 145;
	int stuck = 3;
	int nowstate = 0;
	int state = 0;
	vector<int> marsx(3);
	vector<int> marsy(3);
	Rect mark = Rect(v.x - 40 + xb, v.y - 40 + yb, 240, 210);
	for (;;) {
		waitKey(5);
		Rect target = Rect(xb, yb, 240, 210);
		if (xb > 40 && yb > 40) {
			target.x = xb - 40;
			target.y = yb - 40;
		}
		capture >> frame2;
		img = frame2(target).clone();
		//img = frame2.clone();
		img2 = frame2.clone();
		img3 = frame2.clone();
		img99 = frame2.clone();
		view = img99.clone();
		frame1 = frame1(target).clone();
		frame2 = frame2(target).clone();
		//medianBlur(frame1, frame1, 3);
		//medianBlur(frame2, frame2, 3);
		diff = Bit_Wise2(frame1, frame2);
		medianBlur(diff, diff, 3);
		Canny(diff, edge, 50, 100, 3, true);
		dilate(edge, edge, Mat(), Point(-1, -1), 5);
		Mat img4;

		double white = countNonZero(edge);
		if (white < 1000) {
			//continue;
		}
		
		bitwise_and(img2(target), img2(target), img4, edge);
		//bitwise_and(img2, img2, img4, edge);
		auto algorithm = AKAZE::create();
		vector<KeyPoint> keypoint;
		algorithm->detect(img4, keypoint);
		if (keypoint.size() < 10) {
			continue;
		}
		matching = frame2.clone();

		waitKey(1);
		capture >> src;
		dst = img3.clone();
		difftmp = Bit_Wise2(src, dst);
		medianBlur(difftmp, difftmp, 3);
		Canny(difftmp, edgetmp, 50, 100, 3, true);
		//imshow("tmp", edgetmp);
		waitKey(1);
		//imshow("tmproi", edgetmp_roi);
		matching = templateMatch(edgetmp, edgetmp_roi, img3);
		roi = Rect(xb, yb, 190, 170);

		v = three_seg(keypoint).first;
		theta = three_seg(keypoint).second;
		
		if (v != Point(0, 0)) {
			marsx.at(saturn % 3) = v.x;
			marsy.at(saturn % 3) = v.y;
			saturn++;
			if (saturn % 3 == 2) {
				sort(marsx.begin(), marsx.end());
				sort(marsy.begin(), marsy.end());
				mark.x = marsx.at(1) - 30 + xb;
				mark.y = marsy.at(1) - 30 + yb;
			}
		}

		rectangle(view, mark, Scalar(55, 0, 205), 3, 8);
		imshow("csa", view);

		if (theta > 40) {
			theta += 40;
		}
		else {
			theta -= 40;
		}

		if (theta > 50) {
			stuck++;
		}
		else {
			stuck--;
		}

		if (stuck == 6) {
			nowstate = 1;
		}
		else if (stuck == 0) {
			nowstate = 0;
		}
		else {
			nowstate = state;
		}

		if (venus % 3 == 0) {
			stuck = 3;
		}
		state = nowstate;
		if (nowstate == 1) {
			putText(matching, "open", Point(30, 40), FONT_ITALIC, 1.2, Scalar(255, 200, 100), 2);
		}
		else {
			putText(matching, "close", Point(30, 40), FONT_ITALIC, 1.2, Scalar(255, 200, 100), 2);
		}

		char value_c[256]; //次の行で使う一時的な変数
		sprintf_s(value_c, "%f", theta); //変数の値も含めた表示したい文字列をchar型変数に格納
		fprintf(fp, "%f\n", theta);
		/*
		if (v.x > 0 && v.y > 0) {
			view = img3.clone();
			roi = Rect(v.x, v.y, 190, 170);

			if (v.x > 510 || v.y > 310) {
				continue;
			}

			//rectangle(view, selection2, Scalar(255, 55, 55), 3);
			//printf("%f\n", theta);
			if (theta > 40) {
				//putText(view, "open", Point(50, 50), FONT_ITALIC, 1.2, Scalar(255, 0, 0), 2);
			}
			rectangle(view, roi, Scalar(0, 0, 255), 3);

			//edgetmp_roi = edgetmp(roiroi);
			//imshow("view", view);
			waitKey(1);
			keep_roi = roi;
		}
		*/
		
		imshow("a", matching);
		//imshow("asas", matching2);
		waitKey(1);
		/*
		capture >> frame3;
		origin2 = frame3.clone();
		origin1 = img3.clone();
		src = frame3.clone();
		tmpimg = Bit_Wise2(img3(roi),frame3(roi));//**
		origintmp = Bit_Wise2(origin1, origin2);
		medianBlur(tmpimg, tmpimg, 3);
		medianBlur(origintmp, origintmp, 3);
		Canny(tmpimg, tmpedge, 50, 100, 3, true);
		Canny(origintmp, originedge, 50, 100, 3, true);
		dst = templateMatch(originedge, tmpedge, src);
		imshow("dst", dst);
		imshow("originedge", originedge);
		imshow("tmpedge", tmpedge);
		*/
		/*
		vector<int> m1(5);
		vector<int> m2(5);
		vector<int> m3(5);
		//重心探索
		int a = 0;
		double sumx = 0, sumy = 0;
		for (int i = 0; i < keypoint.size(); i++) {
			sumx += (double)keypoint.at(i).pt.x;
			sumy += (double)keypoint.at(i).pt.y;
			a++;
		}
		G.x = sumx / (double)a;
		G.y = sumy / (double)a;
		circle(img, G, 4, Scalar(255, 0, 255), 2, 5);//重心

		//端点探索
		vector<pair<double, double>> data(a);//radian,distance
		for (int j = 0; j < a; j++) {
			data.at(j).second = sqrt(pow(G.x - (double)keypoint.at(j).pt.x, 2) + pow(G.y - (double)keypoint.at(j).pt.y, 2));
			data.at(j).first = atan2(G.y - (double)keypoint.at(j).pt.y, G.x - (double)keypoint.at(j).pt.x);
		}
		sort(data.begin(), data.end());
		vector<pair<double, int>> store(6);//distance,index
		Point edge1 = Point(0, 0);
		Point edge2 = Point(0, 0);
		Point edge3 = Point(0, 0);
		Point edge_tmp = Point(0, 0);
		double set_radian = -2;
		int s = 0;
		//ラジアン6等分&最大値取得
		for (int k = 0; k < a; k++) {
			if (data.at(k).first > set_radian) {
				set_radian += 1;
				s++;
				if (s > 5) {
					break;
				}
			}

			if (data.at(k).first < set_radian) {
				if (store.at(s).first < data.at(k).second) {
					store.at(s).first = data.at(k).second;
					store.at(s).second = s;
				}
			}
		}

		sort(store.rbegin(), store.rend());
		for (int b = 0; b < 2; b++) {
			if (abs(store.at(b + 1).second - store.at(b).second) < 2) {
				store.at(b + 1) = store.at(b + 2);
				store.at(b + 2) = store.at(b + 3);
			}
		}

		vector<double> distance(a);
		for (int q = 0; q < a; q++) {
			distance.at(q) = sqrt(pow(G.x - (double)keypoint.at(q).pt.x, 2) + pow(G.y - (double)keypoint.at(q).pt.y, 2));
			if (distance.at(q) == store.at(0).first) {
				edge1 = keypoint.at(q).pt;
			}
			else if (distance.at(q) == store.at(1).first) {
				edge2 = keypoint.at(q).pt;
			}
			else if (distance.at(q) == store.at(2).first) {
				edge3 = keypoint.at(q).pt;
			}
		}
		if (sqrt(pow(edge2.x - edge3.x, 2) + pow(edge2.y - edge3.y, 2)) < 40) {
			continue;
		}

		if (edge1.x > edge2.x) {
			edge_tmp = edge2;
			edge2 = edge1;
			edge1 = edge_tmp;
		}
		if (edge1.x > edge3.x) {
			edge_tmp = edge3;
			edge3 = edge1;
			edge1 = edge_tmp;
		}
		circle(img, edge1, 4, Scalar(0, 0, 255), -1, 5);//端点
		circle(img, edge2, 4, Scalar(0, 255, 0), -1, 5);//端点
		circle(img, edge3, 4, Scalar(255, 0, 0), -1, 5);//端点
		imshow("a1", img);
		waitKey(1);

		//領域探索
		vector<double>distance1(a);
		vector<double>distance2(a);
		vector<double>distance3(a);
		vector<vector<Point>>keep1(5, vector<Point>(a));
		vector<vector<Point>>keep2(5, vector<Point>(a));
		vector<vector<Point>>keep3(5, vector<Point>(a));
		vector<Point> G1(5);
		vector<Point> G2(5);
		vector<Point> G3(5);
		vector<pair<double, double>>G1maxstore(6);
		vector<pair<double, double>>G1minstore(6);
		vector<pair<double, double>>G2maxstore(6);
		vector<pair<double, double>>G2minstore(6);
		vector<pair<double, double>>G3maxstore(6);
		vector<pair<double, double>>G3minstore(6);
		vector<double> asp1(5);
		vector<double> asp2(5);
		vector<double> asp3(5);


		for (int r = 0; r < 5; r++) {//領域増加
			int u1 = 0, u2 = 0, u3 = 0;
			double sumx1 = 0;
			double sumy1 = 0;
			double sumx2 = 0;
			double sumy2 = 0;
			double sumx3 = 0;
			double sumy3 = 0;
			double set_distance = (store.at(0).first / 6) * (r + 1);

			for (int u = 0; u < a; u++) {//全体検索
				distance1.at(u) = sqrt(pow(edge1.x - (double)keypoint.at(u).pt.x, 2) + pow(edge1.y - (double)keypoint.at(u).pt.y, 2));
				distance2.at(u) = sqrt(pow(edge2.x - (double)keypoint.at(u).pt.x, 2) + pow(edge2.y - (double)keypoint.at(u).pt.y, 2));
				distance3.at(u) = sqrt(pow(edge3.x - (double)keypoint.at(u).pt.x, 2) + pow(edge3.y - (double)keypoint.at(u).pt.y, 2));
				if (distance1.at(u) < set_distance) {
					sumx1 += keypoint.at(u).pt.x;
					sumy1 += keypoint.at(u).pt.y;
					keep1.at(r).at(u1) = keypoint.at(u).pt;
					circle(img, keypoint.at(u).pt, 1, Scalar(0, 0, 255), 2, 5);
					u1++;
				}

				if (distance2.at(u) < set_distance) {
					sumx2 += keypoint.at(u).pt.x;
					sumy2 += keypoint.at(u).pt.y;
					keep2.at(r).at(u2) = keypoint.at(u).pt;
					circle(img, keypoint.at(u).pt, 1, Scalar(0, 255, 0), 2, 5);
					u2++;
				}

				if (distance3.at(u) < set_distance) {
					sumx3 += keypoint.at(u).pt.x;
					sumy3 += keypoint.at(u).pt.y;
					keep3.at(r).at(u3) = keypoint.at(u).pt;
					circle(img, keypoint.at(u).pt, 1, Scalar(255, 0, 0), 2, 5);
					u3++;
				}
			}

			G1.at(r).x = sumx1 / (double)u1;
			G1.at(r).y = sumy1 / (double)u1;
			G2.at(r).x = sumx2 / (double)u2;
			G2.at(r).y = sumy2 / (double)u2;
			G3.at(r).x = sumx3 / (double)u3;
			G3.at(r).y = sumy3 / (double)u3;

			vector<pair<double, double>> G1data(u1);//radian,distance
			vector<pair<double, double>> G2data(u2);//radian,distance
			vector<pair<double, double>> G3data(u3);//radian,distance

			//長さと角度の計算
			for (int r1 = 0; r1 < u1; r1++) {
				G1data.at(r1).second = sqrt(pow(G1.at(r).x - keep1.at(r).at(r1).x, 2) + pow(G1.at(r).y - keep1.at(r).at(r1).y, 2));
				G1data.at(r1).first = atan2(G1.at(r).y - keep1.at(r).at(r1).y, G1.at(r).x - keep1.at(r).at(r1).x);
			}
			for (int r2 = 0; r2 < u2; r2++) {
				G2data.at(r2).second = sqrt(pow(G2.at(r).x - keep2.at(r).at(r2).x, 2) + pow(G2.at(r).y - keep2.at(r).at(r2).y, 2));
				G2data.at(r2).first = atan2(G2.at(r).y - keep2.at(r).at(r2).y, G2.at(r).x - keep2.at(r).at(r2).x);
			}
			for (int r3 = 0; r3 < u3; r3++) {
				G3data.at(r3).second = sqrt(pow(G3.at(r).x - keep3.at(r).at(r3).x, 2) + pow(G3.at(r).y - keep3.at(r).at(r3).y, 2));
				G3data.at(r3).first = atan2(G3.at(r).y - keep3.at(r).at(r3).y, G3.at(r).x - keep3.at(r).at(r3).x);
			}

			sort(G1data.begin(), G1data.end());
			sort(G2data.begin(), G2data.end());
			sort(G3data.begin(), G3data.end());
			int s1 = 0, s2 = 0, s3 = 0;
			double set_radian1 = -2;
			double set_radian2 = -2;
			double set_radian3 = -2;
			//ラジアン6等分&最大値取得
			for (int e1 = 0; e1 < u1; e1++) {

				if (e1 == 0) {
					G1minstore.at(s1).first = G1data.at(e1).second;
					G1minstore.at(s1).second = G1data.at(e1).first;
				}

				if (G1data.at(e1).first > set_radian1) {
					set_radian1 += 1;
					s1++;
					if (s1 > 5) {
						break;
					}
					G1minstore.at(s1).first = G1data.at(e1).second;
					G1minstore.at(s1).second = G1data.at(e1).first;
				}

				if (G1data.at(e1).first < set_radian1) {
					if (G1maxstore.at(s1).first < G1data.at(e1).second) {
						G1maxstore.at(s1).first = G1data.at(e1).second;
						G1maxstore.at(s1).second = G1data.at(e1).first;
					}

					if (G1minstore.at(s1).first > G1data.at(e1).second) {
						G1minstore.at(s1).first = G1data.at(e1).second;
						G1minstore.at(s1).second = G1data.at(e1).first;
					}
				}
			}

			for (int e2 = 0; e2 < u2; e2++) {
				if (e2 == 0) {
					G2minstore.at(s2).first = G2data.at(e2).second;
					G2minstore.at(s2).second = G2data.at(e2).first;
				}

				if (G2data.at(e2).first > set_radian2) {
					set_radian2 += 1;
					s2++;
					if (s2 > 5) {
						break;
					}
					G2minstore.at(s2).first = G2data.at(e2).second;
					G2minstore.at(s2).second = G2data.at(e2).first;
				}

				if (G2data.at(e2).first < set_radian2) {
					if (G2maxstore.at(s2).first < G2data.at(e2).second) {
						G2maxstore.at(s2).first = G2data.at(e2).second;
						G2maxstore.at(s2).second = G2data.at(e2).first;
					}

					if (G2minstore.at(s2).first > G2data.at(e2).second) {
						G2minstore.at(s2).first = G2data.at(e2).second;
						G2minstore.at(s2).second = G2data.at(e2).first;
					}
				}
			}

			for (int e3 = 0; e3 < u3; e3++) {
				if (e3 == 0) {
					G3minstore.at(s3).first = G3data.at(e3).second;
					G3minstore.at(s3).second = G3data.at(e3).first;
				}

				if (G3data.at(e3).first > set_radian3) {
					set_radian3 += 1;
					s3++;
					if (s3 > 5) {
						break;
					}
					G3minstore.at(s3).first = G3data.at(e3).second;
					G3minstore.at(s3).second = G3data.at(e3).first;
				}

				if (G3data.at(e3).first < set_radian3) {
					if (G3maxstore.at(s3).first < G3data.at(e3).second) {
						G3maxstore.at(s3).first = G3data.at(e3).second;
						G3maxstore.at(s3).second = G3data.at(e3).first;
					}

					if (G3minstore.at(s3).first > G3data.at(e3).second) {
						G3minstore.at(s3).first = G3data.at(e3).second;
						G3minstore.at(s3).second = G3data.at(e3).first;
					}
				}
			}

			sort(G1maxstore.rbegin(), G1maxstore.rend());
			sort(G2maxstore.rbegin(), G2maxstore.rend());
			sort(G3maxstore.rbegin(), G3maxstore.rend());
			sort(G1minstore.begin(), G1minstore.end());
			sort(G2minstore.begin(), G2minstore.end());
			sort(G3minstore.begin(), G3minstore.end());

			if (s1 == 0 || s2 == 0 || s3 == 0) {
				asp1.at(r) = 0;
				asp2.at(r) = 0;
				asp3.at(r) = 0;
				continue;
			}

			int t1 = 0, t2 = 0, t3 = 0;
			for (t1 = 0; t1 < s1; t1++) {
				if (abs(abs(G1minstore.at((double)6 - s1).second) - abs(G1maxstore.at(t1).second)) * 63 < 88 || abs(abs(G1minstore.at((double)6 - s1).second) - abs(G1maxstore.at(t1).second)) * 63 > 110) {
					G1maxstore.at(0) = G1maxstore.at(t1);
				}
				else {
					break;
				}
			}
			for (t2 = 0; t2 < s2; t2++) {
				if (abs(abs(G2minstore.at((double)6 - s2).second) - abs(G2maxstore.at(t2).second)) * 63 < 88 || abs(abs(G2minstore.at((double)6 - s2).second) - abs(G2maxstore.at(t2).second)) * 63 > 110) {
					G2maxstore.at(0) = G2maxstore.at(t2);
				}
				else {
					break;
				}
			}
			for (t3 = 0; t3 < s3; t3++) {
				if (abs(abs(G3minstore.at((double)6 - s3).second) - abs(G3maxstore.at(t3).second)) * 63 < 88 || abs(abs(G3minstore.at((double)6 - s3).second) - abs(G3maxstore.at(t3).second)) * 63 > 110) {
					G3maxstore.at(0) = G3maxstore.at(t3);
				}
				else {
					break;
				}
			}

			asp1.at(r) = G1maxstore.at(0).first / G1minstore.at((double)6 - s1).first;
			asp2.at(r) = G2maxstore.at(0).first / G2minstore.at((double)6 - s2).first;
			asp3.at(r) = G3maxstore.at(0).first / G3minstore.at((double)6 - s3).first;

			imshow("a", img);
			waitKey(1);
			m1.at(r) = u1;
			m2.at(r) = u2;
			m3.at(r) = u3;
		}

		double base_asp1 = 0;
		double base_asp2 = 0;
		double base_asp3 = 0;
		int index1 = 0;
		int index2 = 0;
		int index3 = 0;

		for (int z = 0; z < 5; z++) {
			if (asp1.at(z) > base_asp1) {
				base_asp1 = asp1.at(z);
				index1 = z;
			}
			if (asp2.at(z) > base_asp2) {
				base_asp2 = asp2.at(z);
				index2 = z;
			}
			if (asp3.at(z) > base_asp3) {
				base_asp3 = asp3.at(z);
				index3 = z;
			}
		}

		vector<double> dev1x(m1.at(index1));
		vector<double> dev1y(m1.at(index1));
		vector<double> dev2x(m2.at(index2));
		vector<double> dev2y(m2.at(index2));
		vector<double> dev3x(m3.at(index3));
		vector<double> dev3y(m3.at(index3));
		double powdev1x = 0;
		double powdev1y = 0;
		double powdev2x = 0;
		double powdev2y = 0;
		double powdev3x = 0;
		double powdev3y = 0;
		double var1x = 0;
		double var1y = 0;
		double var2x = 0;
		double var2y = 0;
		double var3x = 0;
		double var3y = 0;
		double Sdev1 = 0;
		double Sdev2 = 0;
		double Sdev3 = 0;
		double cov1 = 0;
		double cov2 = 0;
		double cov3 = 0;
		double a1 = 0;
		double a2 = 0;
		double a3 = 0;
		double b1 = 0;
		double b2 = 0;
		double b3 = 0;
		Point C1 = Point(0, 0);
		Point C2 = Point(0, 0);
		Point C3 = Point(0, 0);
		double c1x = 0;
		double c1y = 0;
		double c2x = 0;
		double c2y = 0;
		double c3x = 0;
		double c3y = 0;

		for (int n1 = 0; n1 < m1.at(index1); n1++) {
			dev1x.at(n1) = keep1.at(index1).at(n1).x - G1.at(index1).x;
			dev1y.at(n1) = keep1.at(index1).at(n1).y - G1.at(index1).y;
			powdev1x += pow(dev1x.at(n1),2);
			powdev1y += pow(dev1y.at(n1),2);
			Sdev1 += dev1x.at(n1) * dev1y.at(n1);
		}
		var1x = powdev1x / (double)m1.at(index1);
		var1y = powdev1y / (double)m1.at(index1);
		cov1 = Sdev1 / (double)m1.at(index1);
		for (int n2 = 0; n2 < m2.at(index2); n2++) {
			dev2x.at(n2) = keep2.at(index2).at(n2).x - G2.at(index2).x;
			dev2y.at(n2) = keep2.at(index2).at(n2).y - G2.at(index2).y;
			powdev2x += pow(dev2x.at(n2), 2);
			powdev2y += pow(dev2x.at(n2), 2);
			Sdev2 += dev2x.at(n2) * dev2y.at(n2);
		}
		var2x = powdev2x / (double)m2.at(index2);
		var2y = powdev2y / (double)m2.at(index2);
		cov2 = Sdev2 / (double)m2.at(index2);
		for (int n3 = 0; n3 < m3.at(index3); n3++) {
			dev3x.at(n3) = keep3.at(index3).at(n3).x - G3.at(index3).x;
			dev3y.at(n3) = keep3.at(index3).at(n3).y - G3.at(index3).y;
			powdev3x += pow(dev3x.at(n3), 2);
			powdev3y += pow(dev3x.at(n3), 2);
			Sdev3 += dev3x.at(n3) * dev3y.at(n3);
		}
		var3x = powdev3x / (double)m3.at(index3);
		var3y = powdev3y / (double)m3.at(index3);
		cov3 = Sdev3 / (double)m3.at(index3);

		a1 = cov1 / var1x;
		a2 = cov2 / var2x;
		a3 = cov3 / var3x;
		b1 = G1.at(index1).y - a1 * G1.at(index1).x;
		b2 = G2.at(index2).y - a2 * G2.at(index2).x;
		b3 = G3.at(index3).y - a3 * G3.at(index3).x;

		c1x = (b2 - b1) / (a1 - a2);
		c1y = a1 * c1x + b1;
		c2x = (b3 - b2) / (a2 - a3);
		c2y = a2 * c2x + b2;
		c3x = (b1 - b3) / (a3 - a1);
		c3y = a3 * c3x + b3;
		printf("%d,%d\n", C1.x, C1.y);
		printf("%d,%d\n", C2.x, C2.y);
		printf("%d,%d\n", C3.x, C3.y);
		//line(img, edge1, G1.at(index1), Scalar(0, 0, 200), 3, 4);
		//line(img, edge2, G2.at(index2), Scalar(0, 200, 0), 3, 4);
		//line(img, edge3, G3.at(index3), Scalar(200, 0, 0), 3, 4);

		Point v1 = center(edge2, G2.at(index2), edge1, G1.at(index1));
		Point v2 = center(edge3, G3.at(index3), edge2, G2.at(index2));
		Point v3 = center(edge1, G1.at(index1), edge3, G3.at(index3));
		//circle(img, C1, 5, Scalar(0, 255, 255), -1, 5);
		//circle(img, C2, 5, Scalar(255, 255, 0), -1, 5);
		//circle(img, C3, 5, Scalar(255, 0, 255), -1, 5);
		Point v = Point(0, 0);
		//v.x = (c1x + c2x + c3x) / 3;
		//v.y = (c1y + c2y + c3y) / 3;
		v.x = (v1.x + v2.x + v3.x) / 3;
		v.y = (v1.y + v2.y + v3.y) / 3;
		if (v.x < edge2.x) {
			circle(img3, v + Point(150, 50), 5, Scalar(155, 155, 155), -1, 5);
			Rect roi(v.x + 150, v.y, 190, 170);
			capture >> frame3;
			origin2 = frame3.clone();
			origin1 = img3.clone();
			src = frame3.clone();
			tmpimg = Bit_Wise2(img3(roi),frame3(roi));
			origintmp = Bit_Wise2(origin1, origin2);
			medianBlur(tmpimg, tmpimg, 3);
			medianBlur(origintmp, origintmp, 3);
			Canny(tmpimg, tmpedge, 50, 100, 3, true);
			Canny(origintmp, originedge, 50, 100, 3, true);
			dst = templateMatch(originedge, tmpedge, src);
			//rectangle(img3, roi, Scalar(255, 55, 255), 1);
			imshow("dst", dst);
			imshow("originedge", originedge);
			imshow("tmpedge", tmpedge);
			waitKey(1);
		}

		Point A = Point(0, 0);
		Point B = Point(0, 0);
		double cos = 0, theta = 0;

		A.x = edge2.x - v.x;
		A.y = edge2.y - v.y;
		B.x = edge3.x - v.x;
		B.y = edge3.y - v.y;

		cos = ((double)A.x * (double)B.x + (double)A.y * (double)B.y) / (sqrt(pow(A.x, 2) + pow(A.y, 2)) * sqrt(pow(B.x, 2) + pow(B.y, 2)));
		theta = acos(cos) * (double)180 / PI;
		if (theta > 90) {
			//imshow("open", img3);
		}
		fprintf(fp, "%f\n",theta);
		waitKey(1);

		if (waitKey(33) == 'q') {
			break;
		}
		*/
		if (waitKey(33) == 'w') {
			capture.release();
			break;
		}
		frame1 = img99.clone();
		venus++;
	}
	return 0;
}
